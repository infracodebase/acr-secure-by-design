# Security Monitoring and SIEM Integration
# Advanced threat detection and security event correlation

apiVersion: v1
kind: Namespace
metadata:
  name: security-monitoring
  labels:
    name: security-monitoring
    purpose: security-analytics
    pod-security.kubernetes.io/enforce: restricted
    pod-security.kubernetes.io/audit: restricted
    pod-security.kubernetes.io/warn: restricted

---
# ConfigMap for Falco security rules
apiVersion: v1
kind: ConfigMap
metadata:
  name: falco-config
  namespace: security-monitoring
  labels:
    app: falco
    component: security-detection
data:
  falco.yaml: |
    # Falco configuration for container security monitoring
    rules_file:
    - /etc/falco/falco_rules.yaml
    - /etc/falco/falco_rules.local.yaml
    - /etc/falco/k8s_audit_rules.yaml

    # gRPC server configuration
    grpc:
      enabled: true
      bind_address: "0.0.0.0:5060"
      threadiness: 0

    # gRPC output
    grpc_output:
      enabled: true

    # JSON output for structured logging
    json_output: true
    json_include_output_property: true

    # Log level
    log_level: info

    # Priority threshold for alerts
    priority: debug

    # Enable syscall events
    syscall_event_drops:
      actions:
      - log
      - alert
      rate: 0.03333
      max_burst: 1000

    # HTTP output to webhook
    http_output:
      enabled: true
      url: "http://security-webhook.security-monitoring:8080/falco"

  falco_rules.local.yaml: |
    # Custom rules for ACR and AKS security monitoring

    # Detect unauthorized container registry access
    - rule: Unauthorized Container Registry Access
      desc: Detect attempts to access unauthorized container registries
      condition: >
        spawned_process and proc.name=docker and
        (proc.cmdline contains "pull" and
         not proc.cmdline contains "${ACR_LOGIN_SERVER}")
      output: >
        Unauthorized container registry access
        (user=%user.name command=%proc.cmdline container=%container.name
         image=%container.image.repository)
      priority: CRITICAL
      tags: [container_registry, unauthorized_access]

    # Detect unsigned image execution
    - rule: Unsigned Container Image
      desc: Detect execution of unsigned container images
      condition: >
        container_started and not
        ka.target.resource.obj contains "notary.signatures"
      output: >
        Unsigned container image started
        (user=%user.name container=%container.name
         image=%container.image.repository:%container.image.tag)
      priority: HIGH
      tags: [image_signing, unauthorized_image]

    # Detect privilege escalation
    - rule: Container Privilege Escalation
      desc: Detect attempts to escalate privileges within containers
      condition: >
        spawned_process and container and
        proc.name in (sudo, su, doas) and not user.name=root
      output: >
        Privilege escalation attempt in container
        (user=%user.name process=%proc.name command=%proc.cmdline
         container=%container.name image=%container.image.repository)
      priority: HIGH
      tags: [privilege_escalation, container_security]

    # Detect sensitive file access
    - rule: Sensitive File Access in Container
      desc: Detect access to sensitive files from containers
      condition: >
        open_read and container and
        (fd.name startswith /etc/shadow or
         fd.name startswith /etc/passwd or
         fd.name startswith /root/.ssh or
         fd.name startswith /home/*/.ssh)
      output: >
        Sensitive file accessed from container
        (user=%user.name file=%fd.name process=%proc.name
         container=%container.name image=%container.image.repository)
      priority: WARNING
      tags: [file_access, sensitive_data]

---
# DaemonSet for Falco
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: falco
  namespace: security-monitoring
  labels:
    app: falco
    component: security-detection
spec:
  selector:
    matchLabels:
      app: falco
  template:
    metadata:
      labels:
        app: falco
        component: security-detection
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "8765"
    spec:
      serviceAccountName: falco
      hostNetwork: true
      hostPID: true
      tolerations:
      - effect: NoSchedule
        key: node-role.kubernetes.io/master
      - effect: NoSchedule
        key: node-role.kubernetes.io/control-plane
      securityContext:
        runAsNonRoot: false  # Falco requires root for syscall monitoring
        runAsUser: 0
      containers:
      - name: falco
        image: falcosecurity/falco-no-driver:0.36.2
        imagePullPolicy: IfNotPresent
        args:
        - /usr/bin/falco
        - --cri=/run/containerd/containerd.sock
        - --cri=/run/crio/crio.sock
        - -K=/var/run/secrets/kubernetes.io/serviceaccount/token
        - -k=https://kubernetes.default
        - --k8s-node=$(FALCO_K8S_NODE_NAME)
        - -pk
        ports:
        - name: grpc
          containerPort: 5060
          protocol: TCP
        - name: http
          containerPort: 8765
          protocol: TCP
        securityContext:
          privileged: true
          readOnlyRootFilesystem: false
        resources:
          limits:
            cpu: 1000m
            memory: 1Gi
          requests:
            cpu: 500m
            memory: 512Mi
        volumeMounts:
        - name: boot
          mountPath: /host/boot
          readOnly: true
        - name: lib-modules
          mountPath: /host/lib/modules
          readOnly: true
        - name: usr-src
          mountPath: /host/usr/src
          readOnly: true
        - name: etc
          mountPath: /host/etc
          readOnly: true
        - name: dev
          mountPath: /host/dev
          readOnly: true
        - name: containerd-sock
          mountPath: /run/containerd/containerd.sock
          readOnly: true
        - name: crio-sock
          mountPath: /run/crio/crio.sock
          readOnly: true
        - name: falco-config
          mountPath: /etc/falco
          readOnly: true
        env:
        - name: FALCO_K8S_NODE_NAME
          valueFrom:
            fieldRef:
              fieldPath: spec.nodeName
        - name: ACR_LOGIN_SERVER
          value: "${ACR_LOGIN_SERVER}"
        livenessProbe:
          httpGet:
            path: /healthz
            port: http
          initialDelaySeconds: 60
          periodSeconds: 15
          timeoutSeconds: 5
        readinessProbe:
          httpGet:
            path: /healthz
            port: http
          initialDelaySeconds: 30
          periodSeconds: 15
          timeoutSeconds: 5
      volumes:
      - name: boot
        hostPath:
          path: /boot
      - name: lib-modules
        hostPath:
          path: /lib/modules
      - name: usr-src
        hostPath:
          path: /usr/src
      - name: etc
        hostPath:
          path: /etc
      - name: dev
        hostPath:
          path: /dev
      - name: containerd-sock
        hostPath:
          path: /run/containerd/containerd.sock
          type: Socket
      - name: crio-sock
        hostPath:
          path: /run/crio/crio.sock
          type: Socket
      - name: falco-config
        configMap:
          name: falco-config

---
# ServiceAccount for Falco
apiVersion: v1
kind: ServiceAccount
metadata:
  name: falco
  namespace: security-monitoring
  labels:
    app: falco
    component: security-detection
automountServiceAccountToken: true

---
# ClusterRole for Falco
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: falco
  labels:
    app: falco
    component: security-detection
rules:
- apiGroups: [""]
  resources: ["nodes", "pods", "services", "events"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["apps"]
  resources: ["deployments", "daemonsets", "replicasets", "statefulsets"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["extensions"]
  resources: ["deployments", "daemonsets", "replicasets"]
  verbs: ["get", "list", "watch"]

---
# ClusterRoleBinding for Falco
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: falco
  labels:
    app: falco
    component: security-detection
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: falco
subjects:
- kind: ServiceAccount
  name: falco
  namespace: security-monitoring

---
# Service for Falco
apiVersion: v1
kind: Service
metadata:
  name: falco
  namespace: security-monitoring
  labels:
    app: falco
    component: security-detection
spec:
  ports:
  - name: grpc
    port: 5060
    targetPort: grpc
    protocol: TCP
  - name: http
    port: 8765
    targetPort: http
    protocol: TCP
  selector:
    app: falco
    component: security-detection

---
# Deployment for security webhook receiver
apiVersion: apps/v1
kind: Deployment
metadata:
  name: security-webhook
  namespace: security-monitoring
  labels:
    app: security-webhook
    component: event-receiver
spec:
  replicas: 2
  selector:
    matchLabels:
      app: security-webhook
      component: event-receiver
  template:
    metadata:
      labels:
        app: security-webhook
        component: event-receiver
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "8080"
    spec:
      serviceAccountName: security-webhook
      securityContext:
        runAsNonRoot: true
        runAsUser: 1000
        runAsGroup: 1000
        fsGroup: 1000
        seccompProfile:
          type: RuntimeDefault
      containers:
      - name: webhook
        image: python:3.11-alpine
        imagePullPolicy: IfNotPresent
        command: ["python3", "-c"]
        args:
          - |
            import json
            import logging
            from http.server import HTTPServer, BaseHTTPRequestHandler
            from urllib.parse import urlparse
            import threading
            import time

            logging.basicConfig(level=logging.INFO)
            logger = logging.getLogger(__name__)

            class SecurityWebhookHandler(BaseHTTPRequestHandler):
                def do_POST(self):
                    if self.path == '/falco':
                        content_length = int(self.headers['Content-Length'])
                        post_data = self.rfile.read(content_length)

                        try:
                            event = json.loads(post_data.decode('utf-8'))
                            logger.info(f"Security event received: {json.dumps(event, indent=2)}")

                            # Process security event
                            priority = event.get('priority', 'UNKNOWN')
                            rule = event.get('rule', 'Unknown Rule')
                            output = event.get('output', '')

                            if priority in ['CRITICAL', 'HIGH']:
                                logger.warning(f"HIGH/CRITICAL security event: {rule} - {output}")
                                # In production, forward to SIEM/alerting system

                            self.send_response(200)
                            self.send_header('Content-type', 'application/json')
                            self.end_headers()
                            self.wfile.write(b'{"status": "received"}')

                        except Exception as e:
                            logger.error(f"Error processing security event: {e}")
                            self.send_error(400, f"Invalid JSON: {e}")

                    elif self.path == '/health':
                        self.send_response(200)
                        self.send_header('Content-type', 'application/json')
                        self.end_headers()
                        self.wfile.write(b'{"status": "healthy"}')

                    else:
                        self.send_error(404)

                def do_GET(self):
                    if self.path == '/health':
                        self.send_response(200)
                        self.send_header('Content-type', 'application/json')
                        self.end_headers()
                        self.wfile.write(b'{"status": "healthy"}')
                    elif self.path == '/metrics':
                        # Simple Prometheus metrics
                        metrics = """
                        # HELP security_events_total Total number of security events received
                        # TYPE security_events_total counter
                        security_events_total 0
                        """
                        self.send_response(200)
                        self.send_header('Content-type', 'text/plain')
                        self.end_headers()
                        self.wfile.write(metrics.encode())
                    else:
                        self.send_error(404)

            if __name__ == '__main__':
                server = HTTPServer(('0.0.0.0', 8080), SecurityWebhookHandler)
                logger.info("Security webhook server starting on port 8080")
                server.serve_forever()
        ports:
        - name: http
          containerPort: 8080
          protocol: TCP
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          capabilities:
            drop:
            - ALL
        resources:
          limits:
            cpu: 200m
            memory: 256Mi
          requests:
            cpu: 100m
            memory: 128Mi
        volumeMounts:
        - name: tmp
          mountPath: /tmp
        livenessProbe:
          httpGet:
            path: /health
            port: http
          initialDelaySeconds: 10
          periodSeconds: 30
        readinessProbe:
          httpGet:
            path: /health
            port: http
          initialDelaySeconds: 5
          periodSeconds: 10
      volumes:
      - name: tmp
        emptyDir:
          sizeLimit: 10Mi

---
# ServiceAccount for security webhook
apiVersion: v1
kind: ServiceAccount
metadata:
  name: security-webhook
  namespace: security-monitoring
  labels:
    app: security-webhook
    component: event-receiver
automountServiceAccountToken: false

---
# Service for security webhook
apiVersion: v1
kind: Service
metadata:
  name: security-webhook
  namespace: security-monitoring
  labels:
    app: security-webhook
    component: event-receiver
spec:
  ports:
  - name: http
    port: 8080
    targetPort: http
    protocol: TCP
  selector:
    app: security-webhook
    component: event-receiver

---
# NetworkPolicy for security monitoring namespace
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: security-monitoring-policy
  namespace: security-monitoring
spec:
  podSelector: {}
  policyTypes:
  - Ingress
  - Egress
  ingress:
  # Allow falco grpc traffic
  - from:
    - namespaceSelector:
        matchLabels:
          name: monitoring
    ports:
    - protocol: TCP
      port: 5060
  # Allow webhook traffic
  - from: []
    ports:
    - protocol: TCP
      port: 8080
  egress:
  # Allow DNS
  - to: []
    ports:
    - protocol: UDP
      port: 53
    - protocol: TCP
      port: 53
  # Allow SIEM/external systems
  - to: []
    ports:
    - protocol: TCP
      port: 443
    - protocol: TCP
      port: 9200  # Elasticsearch
    - protocol: TCP
      port: 5044  # Logstash